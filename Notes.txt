# One-hot vs integer encoding of tile values
    Powers of two naturally suggest a binary representation. The powers of two represented as a bit sequence correspond to one-hot encoding. While tile values are not continuous, numerican comparison is important for the logic of the game. Representing the value as the exponent allows comparison and addition operations (for both the game logic and the neural network).
    I will use integer encoding (i.e n=2^x)
    
    
# move function implementation
    print(timeit.timeit('a.board=np.zeros((4,4))\nfor _ in range(8):\n    a.generate_tile()\na.move_up()',
          setup='from __main__ import a,np',number=10000))
    move_left   => 1.867    
    move_up     => 1.970, 2.037
    move_up_alt => 2.033, 2.025
    move_right  => 1.994, 2.109
    move_right_alt 2.092, 1.994
    move_down   => 2.044, 2.034
    move_down_alt  1.982, 1.960
    alterative is marginally faster by about 0.8%


# merge implementation
    move_left         => 1.886  1.894, 1.851
    move_left_matrix  => 2.041, 2.012, 1.966
    matrix implementation is slower by about 6.9%


# Monte Carlo tree search implementation


# How to reset back to starting state without copying object
    1. Save current board and score
    2. Trace a line
    3. Record score (and board)
    4. Set board and score back to starting state
